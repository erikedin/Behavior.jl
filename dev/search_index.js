var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"functions/#Behavior.runspec","page":"Functions","title":"Behavior.runspec","text":"runspec(rootpath; featurepath, stepspath, execenvpath, parseoptions, presenter, tags)\n\nExecute all features found from the rootpath.\n\nBy default, it looks for feature files in <rootpath>/features and step files <rootpath>/features/steps. An environment.jl file may be added to <rootpath>/features directory for running certain before/after code. You may override the default locations by specifying featurepath, stepspath, or execenvpath.\n\nThe tagselector option is an expression you can use to select which scenarios to run based on tags. For instance, the tag selector @foo will run only those scenarios that have the tag @foo, while not @ignore will run only that scenarios that do not have the @ignore tag.\n\nSee also: Gherkin.ParseOptions.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Behavior.Gherkin.ParseOptions","page":"Functions","title":"Behavior.Gherkin.ParseOptions","text":"ParseOptions lets the user control certain behavior of the parser, making it more lenient towards errors.\n\nThe \"experimental\" Gherkin parser in GherkinExperimental.jl is now the default parser, as it surpassed the older parser in many ways.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Package-layout","page":"Usage","title":"Package layout","text":"A Julia package commonly has the following files and directories:\n\nExamplePackage/\n├── Manifest.toml\n├── Project.toml\n├── src\n│   └── ExamplePackage.jl\n└── test\n    └── runtests.jl\n\nTo use Behavior.jl, add inside the package\n\na directory features\nThis directory will contain the Gherkin feature files.\na directory features/steps\nThis directory will contain the code that runs the actual   test steps.\n\nExamplePackage/\n├── features\n│   ├── Example.feature\n│   └── steps\n│       └── ExampleSteps.jl\n├── Manifest.toml\n├── Project.toml\n├── src\n│   └── ExamplePackage.jl\n└── test\n    └── runtests.jl\n\nAbove you will see a single Gherkin feature file features/Example.feature and a single step definition file features/steps/ExampleSteps.jl.","category":"section"},{"location":"usage/#Test-organization","page":"Usage","title":"Test organization","text":"Behavior searches for both feature files and step files recursively. You may place them in any subdirectory structure that you like. For instance,\n\nExamplePackage/\n├── features\n│   ├── steps\n│   │   ├── ExampleSteps.jl\n│   │   └── substeps\n│   │       └── MoreSteps.jl\n│   ├── subfeature1\n│   │   └── Example.feature\n│   └── subfeature2\n│       └── Other.feature\n├── Manifest.toml\n├── Project.toml\n├── src\n│   └── ExamplePackage.jl\n└── test\n    └── runtests.jl","category":"section"},{"location":"usage/#Making-assertions","page":"Usage","title":"Making assertions","text":"There are currently two ways of making assertions in a step:\n\n@expect <expression>\nChecks that some boolean expression is true, and fails if it is not.\n@fail <string>\nUnconditionally fails a step, with an explanatory string.\n\nBoth these macros are exported from the Behavior module. The @expect macro should be the primary method used for testing the actual vs. expected values of your code. The @fail macro can be used when the @expect macro is not appropriate, or for checking preconditions in the tests.\n\nExamples:\n\nusing Behavior\n\n@then(\"one plus one equals two\") do context\n    @expect 1+1 == 2\nend\n\nusing Behavior\n\n@given(\"some precondition\") do context\n    if !someprecondition()\n        # This may not be part of the test, but a precondition to performing the\n        # actual test you want.\n        @fail \"The tests required this particular precondition to be fulfilled\"\n    end\nend","category":"section"},{"location":"usage/#Parameters","page":"Usage","title":"Parameters","text":"NOTE: This is a work in progress, and will see improvement.\n\nA step in Gherkin is matched against step definitions in Julia code. These step definitions may have parameters, which match against many values. For instance, the Gherkin\n\nFeature: Demonstrating parameters\n\n  Scenario: Value forty-two\n      Given some value 42\n\n  Scenario: Value seventeen\n      Given some value 17\n\nwe have two steps. Both of these steps will match the step definition\n\nusing Behavior\n\n@given(\"value {String}\") do context, value\n    @expect value in [\"42\", \"17\"]\nend\n\nThe step definition above has a parameter {String}, which matches any string following the text value. The additional argument value in the do-block will have the value \"42\" in the first scenario above, and \"17\" in the second.\n\nIn the parameter above we specify the type String. One can also use an empty parameter {} which is an alias for {String}. The type of the argument value will naturally be String.\n\nOne can have several parameters in the step definition. For instance, the step definition\n\nusing Behavior\n\n@given(\"{} {}\") do context, key, value\n    @expect key == \"value\"\n    @expect value in [\"42\", \"17\"]\nend\n\nThis step definition will also match the above Given step, and the first argument key will have the value \"value\" in both the scenarios.\n\nFuture work: In the near future, other types will be supported, such as Int and Float.","category":"section"},{"location":"usage/#Obsolete","page":"Usage","title":"Obsolete","text":"Earlier, parameters were accessible in an object args that was provided to all step implementations, like so\n\n@given(\"value {foo}\") do context\n    @expect args[:foo] in [\"42\", \"17\"]\nend\n\nThis is no longer supported, and the args variable is no longer present.","category":"section"},{"location":"usage/#Data-tables","page":"Usage","title":"Data tables","text":"Gherkin supports tabular data associated with each step. For instance, the scenario\n\nFeature: Demonstrating data tables\n\n    Scenario: Has a table\n        Given some users\n            | user id | name                |\n            | 17      | Henry Case          |\n            | 42      | Ainsley Lowbeer     |\n            | 59      | Chevette Washington |\n         When a search for \"Henry Case\" is made\n         Then user id 17 is found\n\nThe Given step above has a data table associated with it. To access the data table in a step definition, use the datatable field on the context object:\n\nusing Behavior\n\n@given(\"some users\") do context\n    users = context.datatable\n    println(users[1]) # Prints [\"user id\", \"name\"]\n    println(users[2]) # Prints [\"17\", \"Henry Case\"]\n    println(users[3]) # Prints [\"42\", \"Ainsley Lowbeer\"]\n    println(users[4]) # Prints [\"59\", \"Chevette Washington\"]\nend","category":"section"},{"location":"usage/#Strictness-of-Gherkin-syntax","page":"Usage","title":"Strictness of Gherkin syntax","text":"There are some ways to configure how strict we wish the Gherkin parser to be, when reading a feature file. For instance, Behavior by default requires you to only have steps in the order Given-When-Then. It fails if it finds, for instance, a Given step after a When step in a Scenario. This reflects the intended use of these steps, but may not be to everyones liking. Therefore, we can control the strictness of the parser and allow such steps.\n\nFeature: Demonstrating step order\n\n  Scenario: This scenario requires a more lenient parser\n      Given some precondition\n       When some action\n       Then some postcondition\n      Given some other precondition\n       When some other action\n       Then some other postcondition\n\nThe above feature file will by default fail, as the steps are not strictly in the order Given-When-Then. The error message will look something like\n\nERROR: ./features/DemonstratingStepOrder.feature:7\n      Line:     Given some other precondition\n    Reason: bad_step_order\n  Expected: NotGiven\n    Actual: Given\n\nTo allow this, create a Behavior.Gherkin.ParseOptions struct, with the keyword allow_any_step_order = true.\n\njulia> using Behavior\njulia> using Behavior.Gherkin\n\njulia> p = ParseOptions(allow_any_step_order = true)\n\njulia> runspec(parseoptions=p)\n\nNote that at the time of writing, the step order is the only option available for configuration Gherkin parsing.","category":"section"},{"location":"usage/#Step-implementation-suggestions","page":"Usage","title":"Step implementation suggestions","text":"Behavior can find scenario steps that do not have a corresponding step implementation, and suggest one. For instance, if you have the feature\n\n# features/SomeFeature.feature\nFeature: Suggestions example\n\n    Scenario: Some scenario\n        Given an existing step\n         When a step is missing\n\nand the step implementation\n\n# features/steps/somesteps.jl\nusing Behavior\n\n@given(\"an existing step\") do context\n    # Some  test\nend\n\nthen we can see that the step When a step is missing does not have a corresponding step implementation, like the Given step does. To get a suggestion for missing step implementations in a given feature file, you can run\n\njulia> using Behavior\n\njulia> suggestmissingsteps(\"features/SomeFeature.feature\", \"features/steps\")\nusing Behavior\n\n@when(\"a step is missing\") do context\n    @fail \"Implement me\"\nend\n\nIn the code above, we provide suggestmissingsteps with a feature file path, and the path where the step implementations are found. It will find that then When step above is missing and provide you with a sample step implementation. The sample will always initially fail, using the @fail macro, so that it is not accidentally left unimplemented.\n\nNote that suggestmissingsteps can also take a Behavior.Gherkin.ParseOptions as an optional argument, which allows you to configure how strict or lenient the parser should be when reading the feature file.\n\njulia> using Behavior\njulia> using Behavior.Gherkin\n\njulia> suggestmissingsteps(\"features/SomeFeature.feature\", \"features/steps\",\n                           parseoptions=ParseOptions(allow_any_step_order = true))\nusing Behavior\n\n@when(\"a step is missing\") do context\n    @fail \"Implement me\"\nend\n\nAlso note that currently, suggestmissingsteps takes only a single feature file. It would of course be possible to have suggestmissingsteps find all feature files in the project, but this could potentially list too many missing steps to be of use.","category":"section"},{"location":"usage/#Known-limitations","page":"Usage","title":"Known limitations","text":"The suggestion method above does not currently generate any step implementations with variables. This is because the variables are undergoing changes at the time of writing, so generating such implementations would not be stable for the user.","category":"section"},{"location":"usage/#Caution","page":"Usage","title":"Caution","text":"While it's tempting to use this as a means of automatically generating all missing step implementations, it's important to note that Behavior cannot know how to organize the step implementations. Oftentimes, many feature files will share common step implementations, so there will not be a one-to-one correspondence between feature files and the step implementation files. Furthermore, step implementations with variables will often match many steps for different values of the variables, but the suggestion method will not be able to determine which steps you want to use variables for. As an example, in the below feature file, it's quite obvious to a user that a variable step implementation can be used to match all Given some value {Int}, but the suggestion method will not be able to detect this.\n\nFeature: Demonstrate suggestion limitations\n\n    Scenario: Some scenario\n        Given some value 17\n\n    Scenario: Other scenario\n        Given some value 42","category":"section"},{"location":"usage/#Selecting-scenarios-by-tags","page":"Usage","title":"Selecting scenarios by tags","text":"WARNING: At the time of writing the only supported way of selecting tags is a single tag or a comma-separated list of tags, with an optional \"not\" expression:\n\n@tag,\n@tag,@othertag,@thirdtag matches any of the tags\nnot @tag\nnot @tag,@othertag will not match either @tag or @othertag\n\nThe tag selection is a work in progress.\n\nYou can select which scenarios to run using the tags specified in the Gherkin files. For example, a feature file can look like this\n\n@foo\nFeature: Describing tags\n\n    @bar @baz\n    Scenario: Some scenario\n        Given some step\n\n    @ignore\n    Scenario: Ignore this scenario\n        Given some step\n\nHere we have applied the tag @foo to the entire feature file. That is, the @foo tag is inherited by all scenarios in the feature file. One scenario has the @bar and @baz tags, and another has the tag @ignore.\n\nYou can select to run only the scenarios marked with @foo by running\n\njulia> using Behavior\njulia> runspec(tags = \"@foo\")\n\nThis will run both scenarios above, as they both inherit the @foo tag from the feature level.\n\nYou can run only the scenario marked with @bar by running\n\njulia> using Behavior\njulia> runspec(tags = \"@bar\")\n\nThis will run only the first scenario Scenario: Some scenario above, as the second scenario does not have the @bar tag.\n\nYou can also choose to run scenarios that do not have a given tag, such as @ignore.\n\njulia> using Behavior\njulia> runspec(tags = \"not @ignore\")\n\nThis will also run only the first scenario, as it does not have the @ignore tag, but not the second.\n\nIf a feature does not have any matching scenarios, then that feature will be excluded from the results, as it had no bearing on the result.","category":"section"},{"location":"usage/#Tag-selection-syntax","page":"Usage","title":"Tag selection syntax","text":"NOTE: The tag selection syntax is a work in progress.\n\n@tag\nSelect scenarios with the tag @tag.\nnot @tag\nSelect scenarios that do not have the tag @tag.\n@tag,@othertag,@thirdtag\nSelect scenarios that have one or several of the tags @tag, @othertag, @thirdtag.\nnot @tag,@othertag,@thirdtag\nSelect scenarios that do not have any of the tags @tag, @othertag, @thirdtag.","category":"section"},{"location":"usage/#Future-syntax","page":"Usage","title":"Future syntax","text":"In the future, you will be able to write a more complex expression using and, or, and parentheses, like\n\n@foo and (not @ignore)\n\nwhich will run all scenarios with the @foo tag that do not also have the @ignore tag.","category":"section"},{"location":"usage/#Before/after-hooks","page":"Usage","title":"Before/after hooks","text":"You can create hooks that execute before and after each scenario, for set up and tear down of test resources. These must be placed in a file features/environment.jl (or some custom features directory you specify). Note that this is not the features/steps directory, where all step definitions are found, but in the features directory.\n\nThese are the available hooks:\n\n@beforescenario and @afterscenario\n@beforefeature and @afterfeature\n@beforeall and @afterall","category":"section"},{"location":"usage/#Scenario","page":"Usage","title":"Scenario","text":"The @beforescenario and @afterscenario definitions run before and after each scenario.\n\n@beforescenario() do context, scenario\n    # Some code here\nend\n\n@afterscenario() do context, scenario\n    # Some code here\nend\n\nThe intention is that one can place test resources in the context object. This is the same object that the scenario steps will receive as their context parameter, so any modifications to it will be visible in the scenario steps. The scenario parameter allows one to see which scenario is being executed, so test resources can customized for each scenario.","category":"section"},{"location":"usage/#Feature","page":"Usage","title":"Feature","text":"The @beforefeature and @afterfeature definitions run before and after each feature, respectively.\n\n@beforefeature() do feature\n    # Some code here\nend\n\n@afterfeature() do feature\n    # Some code here\nend\n\nNote that these definitions to not take a context parameter. This is because the context is specific to each scenario. Outside of a scenario, there is no context object defined. The feature parameter contains the feature that is about to/was just executed. One can look at which tags are available on it, for instance.\n\nNote that today there are no publicly defined methods on the Behavior.Gherkin.Feature type. To determine what can be done with it, you have to consult the source code. This can obviously be improved.","category":"section"},{"location":"usage/#All","page":"Usage","title":"All","text":"The @beforeall and @afterall runs before the first feature, and after the last feature, respectively.\n\n@beforeall() do\n    # Some code here\nend\n\n@afterall() do\n    # Some code here\nend\n\nThe hooks take no arguments. As of today, these hooks can only create global resources, as no context or feature object is available.","category":"section"},{"location":"usage/#Module-scope","page":"Usage","title":"Module scope","text":"The above hooks are evaluated in the Main module scope. If you define some function myfunction in the environment.jl file, then you can access it by explicitly using Main.myfunction.\n\nHere is an environment.jl file that stores some data used by the all-hooks.\n\nusing Behavior\n\nmyfeatures = []\n\n@beforefeature() do feature\n    push!(myfeatures, feature)\nend\n\nIn a step definition, you can access the myfeatures list by using the Main module\n\nusing Behavior\n\n@then(\"some description\") do\n    latestfeature = Main.myfeatures[end]\n    @expect latestfeature.header.description == \"Some feature description\"\nend","category":"section"},{"location":"usage/#Breaking-on-failure,-or-keep-going","page":"Usage","title":"Breaking on failure, or keep going","text":"During development of a package, it may be advantageous to break on the first failure, if the execution of all features takes a long time. This can be achieved by running the runspec call with the keyword option keepgoing=false. This means that the execution of features will stop at the first failure. No more scenarios or features will execute.\n\nFor example,\n\n@test runspec(pkgdir(MyPackage); keepgoing=false)\n\nThe keepgoing flag defaults to true, meaning that all features are executed.","category":"section"},{"location":"gherkin_experimental/#Gherkin-Experimental-Parser","page":"Gherkin Experimental","title":"Gherkin Experimental Parser","text":"There is a new Gherkin parser, which has support for Rules, and will replace the current Gherkin parser. It is possible to use this new parser today, with an experimental flag.","category":"section"},{"location":"gherkin_experimental/#Command-line","page":"Gherkin Experimental","title":"Command line","text":"If you are running Behavior from the command line, add a flag like this, to try this new parser\n\n$ julia cmd/runspec.jl --experimental\n\n$ julia cmd/suggeststeps.jl features/Some.feature features/steps --experimental\n\n$ julia cmd/parseonly.jl features/ --experimental","category":"section"},{"location":"gherkin_experimental/#Using-ParseOptions","page":"Gherkin Experimental","title":"Using ParseOptions","text":"If you are running Behavior from the runtests.jl script, instead create a ParseOptions struct, like\n\nparseoptions = ParseOptions(use_experimental=true)\nrunspec(\"path/to/project\", parseoptions=parseoptions)","category":"section"},{"location":"gherkin_experimental/#Progress","page":"Gherkin Experimental","title":"Progress","text":"The new parser is on par with the current parser in Behavior.Gherkin, and has additional support for Rules. Aside from the flag describe above, the changes are entirely transparent to the user of Behavior.\n\nThe general idea is that the experimental parser will undergo a period of testing to ensure that no major problems are present, and then it will replace the current parser in a new release.\n\nWhile the parser is mostly on par with the current one, there are still some missing parts, like support for steps But and *. With the new parser, they are fortunately trivial to add.","category":"section"},{"location":"#Behavior.jl-Documentation","page":"Home","title":"Behavior.jl Documentation","text":"BDD is an acronym for Behaviour Driven Development. It is a process for creating and verifying requirements, written in such a way that they can be executed as code. This package aims to be a tool for executing such requirements, and creating reports.","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"Specifications are written in the Gherkin format, such as\n\nFeature: Making coffee\n\n    Scenario: Making a cup of coffee\n        Given that there is a cup in the coffee machine\n         When the \"Coffee\" button is pressed\n         Then the cup is filled with coffee\n\nFor each Given, When, and Then line, a corresponding method is written, which is executed when that line is reached.\n\nusing Behavior\nusing CoffeeMachine\n\nhascoffee(cup::Cup) = cup[:coffee] > 0.0\n\n@given(\"that there is a cup in the coffee machine\") do context\n    cup = Cup()\n    machine = Machine()\n\n    cupisinthemachine(machine, cup)\n\n    context[:cup] = cup\n    context[:machine] = machine\nend\n\n@when(\"the \\\"Coffee\\\" button is pressed\") do context\n    machine = context[:machine]\n    coffeewaspressed(machine)\nend\n\n@then(\"the cup is filled with coffee\") do context\n    cup = context[:cup]\n    @expect hascoffee(cup)\nend\n\nFeature files have extension .feature, and are stored in the features directory (see \"Current state\" for current limitations), and step definitions (the executable code) have the extension .jl and are stored in features/steps.","category":"section"},{"location":"#Example-project","page":"Home","title":"Example project","text":"The project CoffeeMachine.jl is an example of how to use Behavior.jl.","category":"section"},{"location":"#Running","page":"Home","title":"Running","text":"Run the command line tool runspec.jl from the directory containing the features directory, or from the Julia REPL with\n\njulia> using Behavior\njulia> runspec()","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This is a tutorial style introduction to how Behavior.jl works. It is not intended as a complete introduction to Behavior Driven Development, but rather as an introduction to how to start with this package.\n\nThis tutorial assumes that you have Julia 1.0 or later installed. It also assumes you're using Linux, or something similar, but the instructions can be adapted to Windows.\n\nHere is an overview of the steps we'll take:\n\nCreate a new package\nAdd some code to test\nAdd Behavior.jl as a dependency\nWrite a Gherkin feature\nImplement the steps in the feature\nTest the Gherkin feature\nAdd further scenarios\nScenario Outlines\nParameters\n\nIf you have an existing package you wish to use, skip to step 3, and mentally replace the package name CoffeeMachine with your package name.","category":"section"},{"location":"tutorial/#Step-1:-Create-a-new-package","page":"Tutorial","title":"Step 1: Create a new package","text":"Go to a path where you want to create your new package, commonly ~/.julia/dev, and start Julia there.\n\n$ cd ~/.julia/dev\n$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.0 (2021-03-24)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>\n\n\nTo create a new package CoffeeMachine, first enter the Pkg mode by pressing the ] key.\n\njulia> ]\n# The Julia REPL prompt changes to\n(@v1.6) pkg>\n\nCreate the package by running\n\n(@v1.6) pkg> generate CoffeeMachine\n  Generating  project CoffeeMachine:\n    CoffeeMachine/Project.toml\n    CoffeeMachine/src/CoffeeMachine.jl\n\n(@v1.6) pkg>\n\nYou now have a brand new package in ~/.julia/dev/CoffeeMachine.","category":"section"},{"location":"tutorial/#Step-2:-Add-some-code","page":"Tutorial","title":"Step 2: Add some code","text":"Open the file ~/.julia/dev/CoffeeMachine/src/CoffeeMachine.jl and add code so that the CoffeeMachine module looks like this (you can remove the default greet function):\n\nmodule CoffeeMachine\n\nexport Machine, Cup, makecoffee!, fillwith!, readdisplay\n\nmutable struct Machine\n    coffee::Float64\n    milk::Float64\n    message::String\n\n    Machine(; coffee=0.0, milk=0.0) = new(coffee, milk, \"\")\nend\n\nstruct Cup\n    coffee::Float64\n    milk::Float64\nend\n\nfunction fillwith!(m::Machine; coffee=0.0, milk=0.0)\n    m.coffee += coffee\n    m.milk += milk\nend\n\nfunction makecoffee!(m::Machine; withmilk=false) :: Union{Cup, Nothing}\n    if m.coffee <= 0.0\n        display!(m, \"Out of coffee\")\n        return nothing\n    end\n\n    if withmilk && m.milk <= 0.0\n        display!(m, \"Out of milk\")\n        return nothing\n    end\n\n    milkincup = if withmilk\n        1.0\n    else\n        0.0\n    end\n\n    m.coffee -= 1.0\n    m.milk -= milkincup\n\n    display!(m, \"Enjoy\")\n\n    Cup(1.0, milkincup)\nend\n\nreaddisplay(m::Machine) = m.message\ndisplay!(m::Machine, msg::String) = m.message = msg\n\nend # module\n\nThis is a model of a coffee machine, solely for demonstration purposes. It allows you to make a cup of coffee, optionally with milk. It also has a display that shows messages to the user.\n\nIn later steps, we'll create a Gherkin feature that exercises this code.","category":"section"},{"location":"tutorial/#Step-3:-Add-Behavior-as-a-dependency","page":"Tutorial","title":"Step 3: Add Behavior as a dependency","text":"NOTE: Behavior is not yet registered as a package, therefore this tutorial will manually clone the repository from GitHub and add it as a local development dependency.\n\nIn a terminal in ~/.julia/dev, run\n\n$ git clone https://github.com/erikedin/Behavior.jl Behavior\n\nNote that we're cloning it into a repo without the .jl prefix, for consistency with the newly generated package.\n\nStart Julia in ~/.julia/dev and activate the CoffeeMachine package, by\n\n$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.0 (2021-03-24)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>\n\nGo into the package mode and activate CoffeeMachine\n\njulia> ]\n(@v1.6) pkg> activate CoffeeMachine\n  Activating environment at `~/.julia/dev/CoffeeMachine/Project.toml`\n\n(CoffeeMachine) pkg>\n\nTo add Behavior as a local development dependency, run\n\n(CoffeeMachine) pkg> dev Behavior\n[ Info: Resolving package identifier `Behavior` as a directory at `~/.julia/dev/Behavior`.\nPath `Behavior` exists and looks like the correct package. Using existing path.\n   Resolving package versions...\n    Updating `~/.julia/dev/CoffeeMachine/Project.toml`\n  [7a129280] + Behavior v0.1.0 `../Behavior`\n    Updating `~/.julia/dev/CoffeeMachine/Manifest.toml`\n  [7a129280] + Behavior v0.1.0 `../Behavior`\n  [c27321d9] + Glob v1.3.0\n  [2a0f44e3] + Base64\n  [b77e0a4c] + InteractiveUtils\n  [56ddb016] + Logging\n  [d6f4376e] + Markdown\n  [9a3f8284] + Random\n  [9e88b42a] + Serialization\n  [8dfed614] + Test\n\nWe additionally require the standard Test module as a dependency, because we'll use the @test macro in the CoffeeMachine/test/runtests.jl test file later on.\n\n(CoffeeMachine) pkg> add Test\n[ .. output not shown for brevity .. ]","category":"section"},{"location":"tutorial/#Step-4:-Write-a-Gherkin-feature","page":"Tutorial","title":"Step 4: Write a Gherkin feature","text":"Create a directory CoffeeMachine/features.\n\n$ cd ~/.julia/dev/CoffeeMachine\n$ mkdir features\n\nAdd the following Gherkin feature into the file CoffeeMachine/features/MakingCoffee.feature:\n\nFeature: Making Coffee\n\n    Scenario: Making a regular coffee\n        Given a machine filled with coffee beans\n         When a user makes a cup of coffee\n         Then the cup contains coffee\n\nThis file is a simple Gherkin file that contains a requirement that the CoffeeMachine should fulfill.\n\nThe file starts by defining a Feature, with a short description of what this feature is about. A feature file contains one or more Scenarios, and each Scenario has steps on the form Given, When, or Then. In this example, there is one Scenario, with three steps.\n\nThe above requirement simply states that the machine should dispense coffee into the cup, under the assumption that there's enough coffee in the machine.\n\nTo actually run these requirements as code, we need to add implementations for each step above.","category":"section"},{"location":"tutorial/#Step-5:-Implement-the-steps-in-the-feature","page":"Tutorial","title":"Step 5: Implement the steps in the feature","text":"Create a directory CoffeeMachine/features/steps.\n\n$ cd ~/.julia/dev/CoffeeMachine\n$ mkdir -p features/steps\n\nAdd a file CoffeeMachine/features/steps/makingcoffee.jl:\n\nusing Behavior\nusing CoffeeMachine\n\n@given(\"a machine filled with coffee beans\") do context\n    context[:machine] = Machine(coffee=5.0)\nend\n\n@when(\"a user makes a cup of coffee\") do context\n    m = context[:machine]\n    cup = makecoffee!(m)\n    context[:cup] = cup\nend\n\n@then(\"the cup contains coffee\") do context\n    cup = context[:cup]\n\n    @expect cup.coffee > 0.0\nend\n\nThis file begins by using the CoffeeMachine module, which is the thing we wish to test, and the Behavior module, which provides the test functions.\n\nThe first step implementation is\n\n@given(\"a machine filled with coffee beans\") do context\n    context[:machine] = Machine(coffee=5.0)\nend\n\nThis is a Julia implementation of the Scenario step\n\nGiven a machine filled with coffee beans\n\nNote that the string provided to the @given macro matches that of the Given step. This is how Behavior connects the steps in the Gherkin .feature file with actual code.\n\nThe do context ... end is the test function that will run for this step.\n\nThis snippet of code creates a coffee machine using the Machine constructor from the CoffeeMachine module, and provides the coffee machine with 5.0 units of coffee. It then stores this struct in the context dictionary, using the key :machine. The context is a dictionary-like object that stores objects between steps. In this case, the next step will fetch the Machine struct from the context and perform operations on it.\n\nThe second step implementation is\n\n@when(\"a user makes a cup of coffee\") do context\n    m = context[:machine]\n    cup = makecoffee!(m)\n    context[:cup] = cup\nend\n\nThis corresponds to the Scenario step\n\nWhen a user makes a cup of coffee\n\nThis step retrieves the Machine struct from the context. The Machine struct was created in the step before this one. Then we call the makecoffee! function, provided by the CoffeeMachine module, on this machine. We store the returned cup in the context, under the key :cup.\n\nNote that each step ought to perform a single well-defined action. For instance, this step does not make any assumption above what the returned cup actually is. In some cases it will be a Cup struct, and in some cases it will be a Nothing. This step does not care about that, but leaves that to later steps.\n\nThe third and final step checks that the result is what we expect:\n\n@then(\"the cup contains coffee\") do context\n    cup = context[:cup]\n\n    @expect cup.coffee > 0.0\nend\n\nThis step retrieves the cup, which was stored in the context by the previous step. We use the @expect macro to check that the cup does indeed contain coffee. The @expect macro is provided by Behavior, and checks that the provided expression is true. It is very similar to the @test macro in the standard Test module.\n\nIf the above expression was false, say that the returned Cup struct had 0.0 in its coffee field, then the @expect macro would record a failure, and Behavior would show this step as failed.","category":"section"},{"location":"tutorial/#Step-6:-Test-the-Gherkin-feature","page":"Tutorial","title":"Step 6: Test the Gherkin feature","text":"The above steps have created a Gherkin feature file, and a step implementation file, but we need to tell Behavior to run them.\n\nJulias standard location for tests is in the test/runtests.jl file. Add a file CoffeeMachine/test/runtests.jl:\n\nusing Behavior\nusing CoffeeMachine\nusing Test\n\n@test runspec(pkgdir(CoffeeMachine))\n\nThis code calls the Behavior.runspec function, which finds all the feature files and step implementations, and runs all Scenarios. For this example, if will find the Scenario \"Making a regular coffee\", and for each Given/When/Then step, find the matching step implementation in CoffeeMachine/features/steps/makingcoffee.jl, and run it.\n\nThe argument pkgdir(CofeeMachine) simply passes runspec the path to the root of the CoffeeMachine package. From there, it will find the features and features/steps paths.\n\nFinally, the @test macro is used here to ensure that runspec returns true, which it does when all tests pass. If any tests fail, then runspec returns false, and the @test macro records a failure, so that Julia knows it failed. Without the @test macro here, Behavior will still run all tests, and display them, but the standard Julia testrunner will not know that any tests failed.\n\nTo run the tests, enter the package mode for the CoffeeMachine package, and run the test command.\n\njulia> ]\n(CoffeeMachine) pkg> test\n     Testing CoffeeMachine\n     [ .. some Julia output, ignored for brevity .. ]\n     Testing Running tests...\n\nFeature: Making Coffee\n  Scenario: Making a regular coffee\n    Given a machine filled with coffee beans\n     When a user makes a cup of coffee\n     Then the cup contains coffee\n\n                         | Success | Failure\n  Feature: Making Coffee | 1       | 0\n\n\nSUCCESS\n     Testing CoffeeMachine tests passed\n\nBehavior will by default print each Feature, Scenario, and step as they are being executed, and show a final result of how many scenarios succeeded, and how many failed as part of each Feature. Finally, it says SUCCESS to indicate that no errors were found.","category":"section"},{"location":"tutorial/#Optional:-Introduce-an-error-to-see-failures","page":"Tutorial","title":"Optional: Introduce an error to see failures","text":"To see what failures look like, we can intentionally introduce an error into CoffeeMachine.\n\nIn the file CoffeeMachine/src/CoffeeMachine.jl, find the function\n\nfunction makecoffee!(m::Machine; withmilk=false) :: Union{Cup, Nothing}\n    if m.coffee <= 0.0\n        display!(m, \"Out of coffee\")\n        return nothing\n    end\n\n    if withmilk && m.milk <= 0.0\n        display!(m, \"Out of milk\")\n        return nothing\n    end\n\n    milkincup = if withmilk\n        1.0\n    else\n        0.0\n    end\n\n    m.coffee -= 1.0\n    m.milk -= milkincup\n\n    display!(m, \"Enjoy\")\n\n    Cup(1.0, milkincup)\nend\n\nAt the end of this function, change that last line to\n\nfunction makecoffee!(m::Machine; withmilk=false) :: Union{Cup, Nothing}\n    .. keep the rest of the function as is\n\n    Cup(0.0, milkincup)\nend\n\nThis ensures that the cup will not contain any coffee.\n\nFrom the package mode in the CoffeeMachine package, run test again.\n\n(CoffeeMachine) pkg> test\n     Testing CoffeeMachine\n     [ .. output removed for brevity .. ]\n     Testing Running tests...\n\nFeature: Making Coffee\n  Scenario: Making a regular coffee\n    Given a machine filled with coffee beans\n     When a user makes a cup of coffee\n     Then the cup contains coffee\n\n        FAILED: cup.coffee > 0.0\n\n\n                         | Success | Failure\n  Feature: Making Coffee | 0       | 1\n\n\nFAILURE\nTest Failed at /home/erik/.julia/dev/CoffeeMachine/test/runtests.jl:5\n  Expression: runspec(pkgdir(CoffeeMachine))\nERROR: LoadError: There was an error during testing\nin expression starting at /home/erik/.julia/dev/CoffeeMachine/test/runtests.jl:5\nERROR: Package CoffeeMachine errored during testing\n\nYou will see above that while the Given and When steps were successful, the Then step failed, and it shows the expression that failed cup.coffee > 0.0.\n\nFurthermore, the entire feature is marked as failed, and we see that 1 scenario failed in that feature.\n\nTo continue, ensure that you undo the intentional error, so that the tests pass again.","category":"section"},{"location":"tutorial/#Step-7:-Add-further-scenarios","page":"Tutorial","title":"Step 7: Add further scenarios","text":"Add the following Scenario to CoffeeMachine/features/MakingCoffee.feature:\n\nScenario: Making coffee with milk\n    Given a machine filled with coffee beans\n      And that the machine also has milk\n     When a user makes a cup of coffee with milk\n     Then the cup contains coffee\n      And the cup contains milk\n\nNote that some of the steps are the same as the previous Scenario, while others are new.\n\nIf you run the tests again, you will get a failure saying\n\nScenario: Making coffee with milk\n  Given a machine filled with coffee beans\n  Given that the machine also has milk\n\n      No match for 'Given that the machine also has milk'\n\nThis error occurs because we haven't added any step definition for the step And that the machine also has milk yet. The Gherking step type And means that the step type will be whatever came before it, which is a Given in this situation. So, add a step implementation in CoffeeMachine/features/steps/makingcoffee.jl:\n\n@given(\"that the machine also has milk\") do context\n    m = context[:machine]\n    fillwith!(m, milk=5.0)\nend\n\nThis expects that a machine has already been constructed, and simply fills it with milk.\n\nAlso add step implementations for the other new steps:\n\n@when(\"a user makes a cup of coffee with milk\") do context\n    m = context[:machine]\n    cup = makecoffee!(m, withmilk=true)\n    context[:cup] = cup\nend\n\n@then(\"the cup contains milk\") do context\n    cup = context[:cup]\n\n    @expect cup.milk > 0.0\nend\n\nThe first one calls makecoffee!, but this time with the keyword argument withmilk=true, indicating that we want milk in the coffee.\n\nThe second step definition checks that there is milk in the cup.\n\nRuning the tests shows that both scenarios now pass.\n\n(CoffeeMachine) pkg> test\n     Testing CoffeeMachine\n     [ .. removed output for brevity .. ]\n     Testing Running tests...\n\nFeature: Making Coffee\n  Scenario: Making a regular coffee\n    Given a machine filled with coffee beans\n     When a user makes a cup of coffee\n     Then the cup contains coffee\n\n  Scenario: Making coffee with milk\n    Given a machine filled with coffee beans\n    Given that the machine also has milk\n     When a user makes a cup of coffee with milk\n     Then the cup contains coffee\n     Then the cup contains milk\n\n                         | Success | Failure\n  Feature: Making Coffee | 2       | 0\n\n\nSUCCESS\n     Testing CoffeeMachine tests passed\n\nNote that step\n\nThen the cup contains coffee\n\nis reused, as is the initial Given that constructs the coffee machine. It is expected that many, if not most, step definitions will be shared by many scenarios.","category":"section"},{"location":"tutorial/#Step-8:-Scenario-Outlines","page":"Tutorial","title":"Step 8: Scenario Outlines","text":"Scenario Outlines in Gherkin is a way to run one scenario for many similar values. For instance, say that we want to test the machine's error messages when it is out of an ingredient. We could write two different scenarios, one for when the machine is out of coffee, and one for when it is out of milk.\n\nFeature: Displaying messages\n\n    Scenario: Out of coffee\n        Given a machine without coffee\n         When a user makes a cup of coffee with milk\n         Then the machine displays Out of coffee\n\n    Scenario: Out of milk\n        Given a machine without milk\n         When a user makes a cup of coffee with milk\n         Then the machine displays Out of milk\n\nHowever, note that the two scenarios above are nearly identical, only differing in specific values. The sequence of steps are the same, and the type of situation tested is the same. The only differences are which ingredient is missing and which error message we expect. This is a situation where you can use a single Scenario Outline to express more than one Scenario.\n\nCreate a new feature file CoffeeMachine/features/Display.feature:\n\nFeature: Displaying messages\n\n    Scenario Outline: Errors\n        Given a machine without <ingredient>\n         When a user makes a cup of coffee with milk\n         Then the machine displays <message>\n\n        Examples:\n            | ingredient | message       |\n            | coffee     | Out of coffee |\n            | milk       | Out of milk   |\n\nThe above Scenario Outline looks like the above Scenarios, but introduces two placeholders, <ingredient> and <message> instead of specific values. In the Examples: section we have a table that lists which error message we expect for a given missing ingredient. The first line in the table has the two placeholders ingredient and message as column headers.\n\nThis Scenario Outline is exactly equivalent to the two Scenarios above. To run it, create a new step definition file CoffeeMachine/features/steps/display.jl:\n\nusing Behavior\nusing CoffeeMachine\n\n@given(\"a machine without coffee\") do context\n    context[:machine] = Machine(coffee=0.0, milk=5.0)\nend\n\n@given(\"a machine without milk\") do context\n    context[:machine] = Machine(coffee=5.0, milk=0.0)\nend\n\n@then(\"the machine displays Out of coffee\") do context\n    m = context[:machine]\n    @expect readdisplay(m) == \"Out of coffee\"\nend\n\n@then(\"the machine displays Out of milk\") do context\n    m = context[:machine]\n    @expect readdisplay(m) == \"Out of milk\"\nend\n\nYou can run the tests to ensure that they pass.","category":"section"},{"location":"tutorial/#Step-9:-Parameters","page":"Tutorial","title":"Step 9: Parameters","text":"In the above step, we saw how Scenario Outlines can be utilized to reduce otherwise repetitive Scenarios, and improve readability. In the step definition file above, also note that we have two repetitive steps\n\n@then(\"the machine displays Out of coffee\") do context\n    m = context[:machine]\n    @expect readdisplay(m) == \"Out of coffee\"\nend\n\n@then(\"the machine displays Out of milk\") do context\n    m = context[:machine]\n    @expect readdisplay(m) == \"Out of milk\"\nend\n\nThese two steps check the same aspect of the coffee machine, but for two different values. While Scenario Outlines can be used to reduce repetition in .feature files, parameters can be used to reduce repetition in the step definition .jl files.\n\nBoth steps above can be reduced to a single step\n\n@then(\"the machine displays {String}\") do context, message\n    m = context[:machine]\n    @expect readdisplay(m) == message\nend\n\nThere are two differences here:\n\nThe step string has a parameter {String} which matches any text.\nThe do-block function now takes two parameters, context and message.\n\nThe value of the message argument to the do-block is whatever text is matched by {String}. So, for the first example above\n\nThen the machine displays Out of coffee\n\nthis step will match the step definition \"the machine displays {String}\", and the variable message will take on the value Out of coffee.\n\nIn this way, we can write a single step definition to match many Scenario steps.\n\nNote that while the above example uses a Scenario Outline to demonstrate parameters in the step definition .jl file, these are two separate concepts. A step definition with a parameter like {String} can be used for Scenarios as well.","category":"section"}]
}
